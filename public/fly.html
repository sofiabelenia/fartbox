<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maggu's Fly Swat</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #333;
            font-family: 'Fredoka One', cursive;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: none;
        }

        /* UI Overlay Styles */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 20;
        }

        .hud-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-box, .timer-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 15px;
            border: 3px solid #ff6b6b;
            color: #ff6b6b;
            font-size: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .meter-container {
            width: 200px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 15px;
            border: 3px solid #ff6b6b;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .meter-label {
            color: #ff6b6b;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .meter-bar-bg {
            width: 100%;
            height: 20px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ade80, #facc15, #ef4444);
            transition: width 0.2s;
        }

        /* Menus */
        .menu {
            /* Make background slightly transparent to see the fly face */
            background: rgba(255, 255, 255, 0.85);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            border: 5px solid #ff6b6b;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            pointer-events: auto;
            max-width: 90%;
            width: 400px;
            backdrop-filter: blur(5px);
        }

        h1 {
            color: #ff6b6b;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 2px 2px 0px #ffe66d;
        }

        p {
            color: #333;
            font-size: 18px;
            line-height: 1.5;
            margin-bottom: 30px;
            font-weight: bold;
        }

        button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 5px 0 #e04f4f;
        }

        button:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #e04f4f;
        }

        button:hover {
            background: #ff5252;
        }

        .hidden {
            display: none !important;
        }

        /* Floating text for combos */
        .floating-text {
            position: absolute;
            color: #ff6b6b;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            z-index: 15;
        }
        
        /* Weapon unlock notification */
        .unlock-text {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #ff6b6b;
            font-weight: bold;
            font-size: 40px;
            pointer-events: none;
            text-shadow: 3px 3px 0 #fff;
            animation: popIn 2s ease-out forwards;
            z-index: 100;
        }

        /* Screen flash for Nuke */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.1s;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
        
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="flash-overlay"></div>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
        <div class="hud-left">
            <div class="score-box">Score: <span id="scoreDisplay">0</span> / 1000</div>
            <div class="timer-box">Time: <span id="timerDisplay">0.0</span>s</div>
        </div>
        <div class="meter-container">
            <div class="meter-label">ANNOYANCE LEVEL</div>
            <div class="meter-bar-bg">
                <div id="annoyanceBar" class="meter-fill"></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-layer">
        <div class="menu">
            <h1>Maggu's<br>Fly Swat</h1>
            <p>Help Maggu enjoy her picnic!<br>Slap the flies before they annoy her too much.</p>
            <p style="font-size: 14px; margin-top:-20px;">
                <b>GOAL: Reach 1000 Points!</b><br>
                Use Power-ups & Upgrades to survive.
            </p>
            <button id="startBtn">PLAY</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="ui-layer hidden">
        <div class="menu">
            <h1>Game Over!</h1>
            <p>Maggu got too annoyed and left.</p>
            <p>Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">TRY AGAIN</button>
        </div>
    </div>

    <!-- Win Screen -->
    <div id="winScreen" class="ui-layer hidden">
        <div class="menu">
            <h1>PICNIC SAVED!</h1>
            <p>You cleared the swarm!</p>
            <p style="font-size: 24px; color: #4ade80;">Time: <span id="finalTime">0.0</span>s</p>
            <button id="winRestartBtn">PLAY AGAIN</button>
        </div>
    </div>
</div>

<script>
    /**
     * Game Configuration & State
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const winScreen = document.getElementById('winScreen');
    const hud = document.getElementById('hud');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const timerDisplay = document.getElementById('timerDisplay');
    const finalScoreDisplay = document.getElementById('finalScore');
    const finalTimeDisplay = document.getElementById('finalTime');
    const annoyanceBar = document.getElementById('annoyanceBar');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const winRestartBtn = document.getElementById('winRestartBtn');
    const flashOverlay = document.getElementById('flash-overlay');

    // Game State
    let gameState = 'START'; // START, PLAYING, GAMEOVER, WIN
    let score = 0;
    let kills = 0;
    let frames = 0;
    let annoyance = 0;
    let startTime = 0;
    let currentTime = 0;
    const MAX_ANNOYANCE = 100;
    const TARGET_SCORE = 1000;
    
    // Modifiers
    let freezeTimer = 0;

    // Mouse/Touch Input
    const input = { x: 0, y: 0, isDown: false, clickHandled: false };

    // Entities
    let flies = [];
    let splatters = [];
    let particles = [];
    let bonuses = [];
    let hand = null;

    // Resizing
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    /**
     * Utilities
     */
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    function createFloatingText(text, x, y, isUnlock = false, color = '#ff6b6b') {
        const el = document.createElement('div');
        if (isUnlock) {
            el.className = 'unlock-text';
            el.style.top = '20%';
            el.style.left = '0';
        } else {
            el.className = 'floating-text';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
        }
        el.innerText = text;
        el.style.color = color;
        document.getElementById('game-container').appendChild(el);
        setTimeout(() => el.remove(), isUnlock ? 2000 : 1000);
    }

    function triggerFlash() {
        flashOverlay.style.opacity = 1;
        setTimeout(() => {
            flashOverlay.style.opacity = 0;
        }, 100);
    }

    /**
     * Classes
     */
    class Bonus {
        constructor() {
            this.x = randomRange(50, canvas.width - 50);
            this.y = randomRange(50, canvas.height - 50);
            // 50/50 Chance for Freeze or Nuke
            this.type = Math.random() < 0.5 ? 'FREEZE' : 'NUKE';
            this.life = 300; // 5 seconds (at 60fps) to grab it
            this.scale = 0;
            this.active = true;
            this.wobble = Math.random() * 10;
        }

        update() {
            // Pop in
            if (this.scale < 1) this.scale += 0.1;
            
            // Drift slightly
            this.y += Math.sin(this.wobble) * 0.5;
            this.wobble += 0.05;

            this.life--;
            // Flicker when dying
            if (this.life < 60 && this.life % 10 < 5) {
                // Invisible for flicker effect
            } 
            
            if (this.life <= 0) {
                this.active = false;
            }
        }

        draw(ctx) {
            if (this.life < 60 && this.life % 10 < 5) return;

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale, this.scale);

            // Glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.type === 'FREEZE' ? '#4deeea' : '#ff4757';

            // Orb
            let grad = ctx.createRadialGradient(0,0,5, 0,0,25);
            if (this.type === 'FREEZE') {
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.5, '#4deeea');
                grad.addColorStop(1, '#00b8d4');
            } else {
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.5, '#ff6b6b');
                grad.addColorStop(1, '#c0392b');
            }
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI*2);
            ctx.fill();

            // Icon
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText(this.type === 'FREEZE' ? 'â„ï¸' : 'ðŸ”¥', 0, 2);

            ctx.restore();
        }
    }

    class Hand {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.targetX = this.x;
            this.targetY = this.y;
            this.angle = 0;
            this.scale = 1;
            this.slapState = 'IDLE'; // IDLE, SLAPPING, RECOVERING
            this.slapTimer = 0;
            this.weapon = 'HAND'; // HAND, SWATTER, SPRAY, ZAPPER, GOLDEN
            this.wobble = 0; // For idle animation
        }

        getDamage() {
            switch(this.weapon) {
                case 'HAND': return 1;
                case 'SWATTER': return 2;
                case 'SPRAY': return 2; // Continuous/Wide
                case 'ZAPPER': return 5;
                case 'GOLDEN': return 100; // Insta-kill
                default: return 1;
            }
        }

        update() {
            this.wobble += 0.1;

            // Weapon Upgrade Logic
            if (kills >= 50 && this.weapon !== 'GOLDEN') {
                this.weapon = 'GOLDEN';
                createFloatingText("GOLDEN GAUNTLET UNLOCKED!", 0, 0, true);
            } else if (kills >= 30 && kills < 50 && this.weapon !== 'ZAPPER') {
                this.weapon = 'ZAPPER';
                createFloatingText("ELECTRIC RACKET UNLOCKED!", 0, 0, true);
            } else if (kills >= 15 && kills < 30 && this.weapon !== 'SPRAY') {
                this.weapon = 'SPRAY';
                createFloatingText("BUG SPRAY UNLOCKED!", 0, 0, true);
            } else if (kills >= 5 && kills < 15 && this.weapon !== 'SWATTER') {
                this.weapon = 'SWATTER';
                createFloatingText("SWATTER UNLOCKED!", 0, 0, true);
            }

            // Smooth movement (LERP)
            this.targetX = input.x;
            this.targetY = input.y;
            
            this.x += (this.targetX - this.x) * 0.2;
            this.y += (this.targetY - this.y) * 0.2;

            // Rotate based on velocity for dynamic feel
            const dx = this.targetX - this.x;
            this.angle = dx * 0.005;

            // Slap/Action Logic
            if (this.slapState === 'IDLE') {
                if (input.isDown && !input.clickHandled) {
                    this.slapState = 'SLAPPING';
                    this.slapTimer = 0;
                    input.clickHandled = true; // Consumed
                }
            } else if (this.slapState === 'SLAPPING') {
                this.slapTimer++;
                
                // Motion depends on weapon
                if (this.weapon === 'SPRAY') {
                     this.x += randomRange(-5, 5); // Shake
                } else if (this.weapon === 'ZAPPER') {
                    this.x += randomRange(-2, 2); // Electrical hum vibrate
                    this.scale = 1 - (this.slapTimer / 5) * 0.1;
                } else if (this.weapon === 'GOLDEN') {
                    this.scale = 1.2 - (this.slapTimer / 5) * 0.1; // Big smash
                } else {
                     this.scale = 1 - (this.slapTimer / 5) * 0.2; 
                }
                
                if (this.slapTimer >= 5) {
                    // HIT MOMENT
                    this.checkHit();
                    this.slapState = 'RECOVERING';
                    this.slapTimer = 0;
                }
            } else if (this.slapState === 'RECOVERING') {
                this.slapTimer++;
                // Bounce back up
                if (this.weapon !== 'SPRAY') {
                    let recoverSpeed = this.weapon === 'GOLDEN' ? 0.05 : 0.2;
                    this.scale += recoverSpeed;
                }
                if (this.slapTimer >= 10) {
                    this.scale = this.weapon === 'GOLDEN' ? 1.2 : 1;
                    this.slapState = 'IDLE';
                }
            }
        }

        checkHit() {
            let hitRadius = 50;
            let hitX = this.x;
            let hitY = this.y - 10;
            let particleColor = '#fff';

            // Weapon Configs
            if (this.weapon === 'SWATTER') {
                hitRadius = 90; 
                hitY = this.y - 80;
                particleColor = '#ccc';
            } else if (this.weapon === 'SPRAY') {
                hitRadius = 130; 
                hitY = this.y - 90;
                particleColor = '#80ff80'; 
                // Spawn gas
                for(let i=0; i<20; i++) {
                     particles.push(new Particle(hitX + randomRange(-40, 40), hitY + randomRange(-40, 40), '#a3ffac', randomRange(5, 15), 0.5));
                }
            } else if (this.weapon === 'ZAPPER') {
                hitRadius = 110;
                hitY = this.y - 100;
                particleColor = '#4deeea';
                // Electric sparks
                for(let i=0; i<15; i++) {
                     particles.push(new Particle(hitX + randomRange(-40, 40), hitY + randomRange(-40, 40), '#fff', randomRange(2, 6), 0, true));
                }
            } else if (this.weapon === 'GOLDEN') {
                hitRadius = 300; // Screen wipe almost
                hitY = this.y;
                particleColor = '#ffd700';
                // Holy blast
                for(let i=0; i<30; i++) {
                     particles.push(new Particle(hitX, hitY, '#ffd700', randomRange(5, 20), 0, false, 20));
                }
            }

            // Visual feedback
            if (this.weapon !== 'SPRAY') {
                for(let i=0; i<5; i++) {
                    particles.push(new Particle(hitX, hitY, particleColor, 3));
                }
            }

            // --- CHECK BONUS COLLISIONS ---
            for (let i = bonuses.length - 1; i >= 0; i--) {
                const b = bonuses[i];
                const dx = b.x - hitX;
                const dy = b.y - hitY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < hitRadius) {
                    // Activate Bonus
                    if (b.type === 'FREEZE') {
                        freezeTimer = 300; // 5 seconds
                        createFloatingText("â„ï¸ FROZEN! â„ï¸", b.x, b.y, false, '#4deeea');
                    } else if (b.type === 'NUKE') {
                        triggerFlash();
                        createFloatingText("ðŸ”¥ BOOM! ðŸ”¥", b.x, b.y, false, '#ff4757');
                        // Kill all flies
                        flies.forEach(f => f.die(true, true)); // Reuse 'holy' visual for nuke
                        kills += flies.length;
                        score += flies.length * 2;
                        flies = []; // Clear array
                    }
                    bonuses.splice(i, 1);
                }
            }

            // --- CHECK FLY COLLISIONS ---
            let hitCount = 0;
            const dmg = this.getDamage();

            for (let i = flies.length - 1; i >= 0; i--) {
                const fly = flies[i];
                const dx = fly.x - hitX;
                const dy = fly.y - hitY;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < hitRadius) { // Standard collision
                    fly.takeDamage(dmg, this.weapon);
                    if (fly.isDead) {
                        hitCount++;
                    } else {
                        // Feedback for hitting big fly but not killing
                         createFloatingText("HIT!", fly.x, fly.y - 30);
                         fly.hitFlash = 5; // Frames to flash white
                    }
                }
            }

            if (hitCount > 0) {
                kills += hitCount;
                let bonus = 1;
                if (this.weapon === 'SPRAY') bonus = 2;
                if (this.weapon === 'ZAPPER') bonus = 3;
                if (this.weapon === 'GOLDEN') bonus = 5;
                
                score += hitCount * bonus;
                
                if (hitCount > 1) {
                    createFloatingText("COMBO x" + hitCount + "!", this.x, this.y - 50);
                }
                
                // Reduce annoyance
                annoyance = Math.max(0, annoyance - (2 * hitCount));

                // Win Condition Check
                if (score >= TARGET_SCORE) {
                    winGame();
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.scale(this.scale, this.scale);

            // Arm/Hand Common Settings
            let skinColor = '#fce4d4';
            let shadowColor = '#eebb99';
            let nailColor = '#ff6b81';
            let braceletColor = '#ffd700';

            if (this.weapon === 'GOLDEN') {
                skinColor = '#ffd700';
                shadowColor = '#d4af37';
                nailColor = '#fff';
                braceletColor = '#fff';
                
                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffd700';
            } else {
                ctx.shadowBlur = 0;
            }

            // --- DRAW ARM ---
            // Gradient for arm roundness
            let armGrad = ctx.createLinearGradient(-20, 0, 20, 0);
            armGrad.addColorStop(0, shadowColor);
            armGrad.addColorStop(0.3, skinColor);
            armGrad.addColorStop(0.8, skinColor);
            armGrad.addColorStop(1, shadowColor);

            ctx.fillStyle = armGrad;
            ctx.beginPath();
            ctx.moveTo(-15, 100);
            ctx.lineTo(15, 100);
            ctx.lineTo(12, 250); // Longer arm offscreen
            ctx.lineTo(-12, 250);
            ctx.fill();

            // Wrist Accessory
            ctx.fillStyle = braceletColor;
            ctx.fillRect(-16, 90, 32, 8);
            if(this.weapon !== 'GOLDEN') {
                ctx.fillStyle = '#ffec8b';
                ctx.fillRect(-16, 92, 32, 2);
            }

            if (this.weapon === 'HAND' || this.weapon === 'GOLDEN') {
                this.drawBeautifulHand(ctx, skinColor, shadowColor, nailColor);
            } else if (this.weapon === 'SWATTER') {
                this.drawHandHoldingSwatter(ctx, skinColor, shadowColor, nailColor);
            } else if (this.weapon === 'SPRAY') {
                this.drawHandHoldingSpray(ctx, skinColor, shadowColor, nailColor);
            } else if (this.weapon === 'ZAPPER') {
                this.drawHandHoldingZapper(ctx, skinColor, shadowColor, nailColor);
            }

            ctx.restore();
        }

        drawBeautifulHand(ctx, skin, shadow, nail) {
            // Palm
            ctx.fillStyle = skin;
            ctx.beginPath();
            ctx.ellipse(0, 40, 35, 45, 0, 0, Math.PI * 2);
            ctx.fill();

            // Fingers
            const fingers = [
                {x: -28, y: -5, w: 14, h: 50, ang: -0.2},
                {x: -10, y: -20, w: 16, h: 65, ang: -0.1},
                {x: 10, y: -20, w: 16, h: 70, ang: 0},
                {x: 28, y: -5, w: 15, h: 60, ang: 0.1}
            ];

            fingers.forEach(f => {
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.ang);
                ctx.fillStyle = skin;
                ctx.beginPath();
                ctx.moveTo(-f.w/2, 0);
                ctx.lineTo(-f.w/2 + 2, -f.h);
                ctx.quadraticCurveTo(0, -f.h - 5, f.w/2 - 2, -f.h);
                ctx.lineTo(f.w/2, 0);
                ctx.fill();
                ctx.fillStyle = nail;
                ctx.beginPath();
                ctx.ellipse(0, -f.h + 5, f.w/3, f.w/2.5, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.beginPath();
                ctx.ellipse(-2, -f.h + 4, 1.5, 3, 0.2, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            });

            // Thumb
            ctx.save();
            ctx.translate(35, 60);
            ctx.rotate(0.6);
            ctx.fillStyle = skin;
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.lineTo(-8, -45);
            ctx.quadraticCurveTo(0, -52, 8, -45);
            ctx.lineTo(8, 0);
            ctx.fill();
            ctx.fillStyle = nail;
            ctx.beginPath();
            ctx.ellipse(0, -38, 6, 7, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        drawHandHoldingSwatter(ctx, skin, shadow, nail) {
             // Handle Stick
             ctx.fillStyle = '#555';
             ctx.fillRect(-5, -50, 10, 150);

             // Swatter Head
             ctx.save();
             ctx.translate(0, -120);
             ctx.fillStyle = 'rgba(255, 100, 100, 0.4)';
             ctx.fillRect(-45, -45, 90, 90);
             ctx.strokeStyle = '#d00';
             ctx.lineWidth = 2;
             ctx.strokeRect(-45, -45, 90, 90);
             ctx.beginPath();
             for(let i=-35; i<45; i+=15) {
                 ctx.moveTo(i, -45); ctx.lineTo(i, 45);
                 ctx.moveTo(-45, i); ctx.lineTo(45, i);
             }
             ctx.stroke();
             ctx.restore();

             this.drawCurledFingers(ctx, skin, nail);
        }

        drawHandHoldingZapper(ctx, skin, shadow, nail) {
            // Handle
            ctx.fillStyle = '#222';
            ctx.fillRect(-8, -50, 16, 150);

            // Zapper Head (Tennis racket style)
            ctx.save();
            ctx.translate(0, -130);
            
            // Outer Frame
            ctx.fillStyle = '#facc15'; // Yellow plastic
            ctx.beginPath();
            ctx.ellipse(0, 0, 55, 70, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#222'; // Inner hole
            ctx.beginPath();
            ctx.ellipse(0, 0, 45, 60, 0, 0, Math.PI*2);
            ctx.fill();

            // Electric Grid
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=-40; i<40; i+=8) {
                ctx.moveTo(i, -50); ctx.lineTo(i, 50); // Vertical
                ctx.moveTo(-40, i*1.2); ctx.lineTo(40, i*1.2); // Horiz
            }
            ctx.stroke();

            // Arcs (Animation)
            if (frames % 10 < 5) {
                ctx.strokeStyle = '#4deeea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-20, -20); ctx.lineTo(20, 20);
                ctx.moveTo(20, -20); ctx.lineTo(-20, 20);
                ctx.stroke();
            }

            ctx.restore();
            this.drawCurledFingers(ctx, skin, nail);
        }

        drawHandHoldingSpray(ctx, skin, shadow, nail) {
            ctx.save();
            ctx.translate(0, -50);
            let canGrad = ctx.createLinearGradient(-25, 0, 25, 0);
            canGrad.addColorStop(0, '#004d00');
            canGrad.addColorStop(0.5, '#00b300');
            canGrad.addColorStop(1, '#004d00');
            ctx.fillStyle = canGrad;
            ctx.fillRect(-25, -60, 50, 140);
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.arc(0, -60, 24, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = 'red';
            ctx.fillRect(-5, -84, 10, 10);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.fillText("TOXIC", -18, 0);
            ctx.restore();

             ctx.fillStyle = skin;
             ctx.beginPath();
             ctx.ellipse(10, 60, 30, 40, 0, 0, Math.PI*2);
             ctx.fill();

             ctx.beginPath();
             ctx.moveTo(15, 30);
             ctx.lineTo(5, -120); 
             ctx.lineWidth = 14;
             ctx.strokeStyle = skin;
             ctx.lineCap = 'round';
             ctx.stroke();
             
             ctx.fillStyle = nail;
             ctx.beginPath();
             ctx.ellipse(5, -125, 5, 6, 0, 0, Math.PI*2);
             ctx.fill();

             for(let i=0; i<3; i++) {
                 ctx.beginPath();
                 ctx.ellipse(25, 20 + (i*15), 18, 8, 0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = nail;
                 ctx.beginPath();
                 ctx.ellipse(35, 20 + (i*15), 4, 6, 0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = skin;
             }
        }

        drawCurledFingers(ctx, skin, nail) {
             ctx.fillStyle = skin;
             ctx.beginPath();
             ctx.ellipse(0, 50, 35, 35, 0, 0, Math.PI * 2);
             ctx.fill();
             const knuckles = [-25, -8, 8, 25];
             knuckles.forEach((kx, i) => {
                 ctx.fillStyle = skin;
                 ctx.beginPath();
                 ctx.ellipse(kx, 25 - Math.abs(kx)*0.1, 10, 12, 0, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = nail;
                 ctx.beginPath();
                 ctx.ellipse(kx, 28 - Math.abs(kx)*0.1, 6, 4, 0, 0, Math.PI*2);
                 ctx.fill();
             });
        }
    }

    class Fly {
        constructor() {
            // Big Fly Logic
            this.isBig = Math.random() < 0.05; // 5% chance spawn
            this.hp = this.isBig ? 5 : 1;
            this.scaleMult = this.isBig ? 2.5 : 1;

            if (Math.random() < 0.5) {
                this.x = Math.random() < 0.5 ? -20 : canvas.width + 20;
                this.y = Math.random() * canvas.height;
            } else {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() < 0.5 ? -20 : canvas.height + 20;
            }
            
            let baseSpeed = randomRange(3, 6 + (score / 20));
            if (this.isBig) baseSpeed *= 0.5; // Big flies are slower

            this.vx = randomRange(-2, 2);
            this.vy = randomRange(-2, 2);
            this.speed = baseSpeed;
            this.angle = 0;
            this.wingState = 0;
            this.targetX = Math.random() * canvas.width;
            this.targetY = Math.random() * canvas.height;
            this.changeDirTimer = 0;
            this.isDead = false;
            this.hitFlash = 0;
        }

        takeDamage(amount, weaponType) {
            this.hp -= amount;
            if (this.hp <= 0) {
                let zapped = weaponType === 'ZAPPER';
                let holy = weaponType === 'GOLDEN' || weaponType === 'NUKE'; // Nuke uses holy effect
                this.die(zapped, holy);
            }
        }

        update() {
            if (this.isDead) return;

            // FREEZE LOGIC
            if (freezeTimer > 0) {
                // Just jitter
                this.x += randomRange(-0.5, 0.5);
                this.y += randomRange(-0.5, 0.5);
                this.wingState += 0.2; // Slow wings
                return;
            }

            this.changeDirTimer--;
            if (this.changeDirTimer <= 0) {
                this.targetX = Math.random() * canvas.width;
                this.targetY = Math.random() * canvas.height;
                this.changeDirTimer = randomRange(30, 100);
            }

            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 0) {
                this.vx += (dx / dist) * 0.5;
                this.vy += (dy / dist) * 0.5;
            }

            const velocity = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (velocity > this.speed) {
                this.vx = (this.vx / velocity) * this.speed;
                this.vy = (this.vy / velocity) * this.speed;
            }

            this.x += this.vx + randomRange(-2, 2);
            this.y += this.vy + randomRange(-2, 2);
            this.angle = Math.atan2(this.vy, this.vx);
            this.wingState += 1;

            if (this.x > 0 && this.x < canvas.width && this.y > 0 && this.y < canvas.height) {
                annoyance += this.isBig ? 0.06 : 0.03; // Big flies annoy more
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scaleMult, this.scaleMult);
            ctx.rotate(this.angle + Math.PI/2);

            // Hit Flash
            if (this.hitFlash > 0) {
                ctx.globalCompositeOperation = 'source-over'; // Normal
                // Could use overlay but simpler to just tint
                this.hitFlash--;
            }

            // Wings
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const wingOffset = Math.sin(this.wingState) * 5;
            ctx.beginPath();
            ctx.ellipse(-8 - wingOffset, 5, 8, 12, -0.5, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8 + wingOffset, 5, 8, 12, 0.5, 0, Math.PI*2);
            ctx.fill();

            // Body
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#222';
            ctx.beginPath();
            ctx.ellipse(0, 0, 6, 10, 0, 0, Math.PI*2);
            ctx.fill();

            // Eyes (Red)
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#d00';
            ctx.beginPath();
            ctx.arc(-3, -6, 3, 0, Math.PI*2);
            ctx.arc(3, -6, 3, 0, Math.PI*2);
            ctx.fill();
            
            // Big Fly Details (Crown/Spikes)
            if (this.isBig) {
                 ctx.fillStyle = '#f1c40f';
                 ctx.beginPath();
                 ctx.moveTo(-4, -10); ctx.lineTo(-2, -15); ctx.lineTo(0, -10); ctx.lineTo(2, -15); ctx.lineTo(4, -10);
                 ctx.fill();
            }

            ctx.restore();
        }

        die(zapped = false, holy = false) {
            this.isDead = true;
            let scale = this.isBig ? 2 : 1;

            if (holy) {
                 splatters.push(new Splatter(this.x, this.y, '#ffd700', scale));
            } else if (zapped) {
                 splatters.push(new Splatter(this.x, this.y, '#222', scale)); // Ash mark
                 for(let i=0; i<8; i++) {
                    particles.push(new Particle(this.x, this.y, '#4deeea', randomRange(2,5), 0, true));
                }
            } else {
                 splatters.push(new Splatter(this.x, this.y, '#2d4a1c', scale));
                 for(let i=0; i<8; i++) {
                    particles.push(new Particle(this.x, this.y, '#5c1919', randomRange(2,5)));
                }
            }
        }
    }

    class Splatter {
        constructor(x, y, color, scaleMult = 1) {
            this.x = x;
            this.y = y;
            this.alpha = 1;
            this.scale = randomRange(0.8, 1.5) * scaleMult;
            this.rotation = Math.random() * Math.PI * 2;
            this.life = 600;
            this.color = color;
        }

        update() {
            this.life--;
            if (this.life < 60) {
                this.alpha = this.life / 60;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale, this.scale);
            ctx.globalAlpha = this.alpha;

            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.bezierCurveTo(10, -15, 15, -5, 10, 0);
            ctx.bezierCurveTo(15, 10, 5, 15, 0, 10);
            ctx.bezierCurveTo(-10, 15, -15, 5, -10, 0);
            ctx.bezierCurveTo(-15, -10, -5, -15, 0, -10);
            ctx.fill();
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, size, driftSpeed = 0, electric = false, explodeSpeed = 0) {
            this.x = x;
            this.y = y;
            if (explodeSpeed > 0) {
                let ang = Math.random() * Math.PI * 2;
                let spd = Math.random() * explodeSpeed;
                this.vx = Math.cos(ang) * spd;
                this.vy = Math.sin(ang) * spd;
            } else {
                this.vx = randomRange(-5, 5);
                this.vy = randomRange(-5, 5);
            }
            this.color = color;
            this.size = size;
            this.life = 30;
            this.driftSpeed = driftSpeed;
            this.electric = electric;
        }

        update() {
            if (this.driftSpeed > 0) {
                this.x += this.vx * 0.2;
                this.y += this.vy * 0.2 - 1;
                this.size *= 1.02;
            } else {
                this.x += this.vx;
                this.y += this.vy;
                if (!this.electric) this.size *= 0.9;
            }
            this.life--;
        }

        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life / 30;
            ctx.beginPath();
            if (this.electric) {
                // Draw jagged line or square
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + randomRange(-5, 5), this.y + randomRange(-5,5));
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }

    /**
     * Input Handling
     */
    window.addEventListener('mousemove', e => {
        input.x = e.clientX;
        input.y = e.clientY;
    });

    window.addEventListener('touchmove', e => {
        e.preventDefault();
        input.x = e.touches[0].clientX;
        input.y = e.touches[0].clientY;
    }, {passive: false});

    window.addEventListener('mousedown', () => {
        input.isDown = true;
        input.clickHandled = false;
    });

    window.addEventListener('touchstart', (e) => {
        input.x = e.touches[0].clientX;
        input.y = e.touches[0].clientY;
        input.isDown = true;
        input.clickHandled = false;
    });

    window.addEventListener('mouseup', () => input.isDown = false);
    window.addEventListener('touchend', () => input.isDown = false);

    /**
     * Game Loop
     */
    function startGame() {
        score = 0;
        kills = 0;
        annoyance = 0;
        flies = [];
        splatters = [];
        particles = [];
        bonuses = [];
        freezeTimer = 0;
        hand = new Hand();
        input.x = canvas.width/2;
        input.y = canvas.height/2;

        startTime = Date.now();
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        winScreen.classList.add('hidden');
        hud.classList.remove('hidden');
        
        gameState = 'PLAYING';
    }

    function endGame() {
        gameState = 'GAMEOVER';
        hud.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
        finalScoreDisplay.innerText = score;
    }

    function winGame() {
        gameState = 'WIN';
        hud.classList.add('hidden');
        winScreen.classList.remove('hidden');
        let elapsed = (Date.now() - startTime) / 1000;
        finalTimeDisplay.innerText = elapsed.toFixed(1);
    }

    function drawStartScreenFly() {
        // Draw a giant stylized fly face in the background
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        // Bobbing animation
        const bob = Math.sin(frames * 0.02) * 20;

        ctx.save();
        ctx.translate(cx, cy + bob);
        ctx.scale(2, 2); // Make it huge

        // Head
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.ellipse(0, 0, 100, 80, 0, 0, Math.PI*2);
        ctx.fill();
        
        // Fuzz (Simple)
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        for(let i=0; i<360; i+=10) {
            let rad = i * (Math.PI/180);
            ctx.beginPath();
            ctx.moveTo(Math.cos(rad)*90, Math.sin(rad)*70);
            ctx.lineTo(Math.cos(rad)*110, Math.sin(rad)*90);
            ctx.stroke();
        }

        // Eyes (Compound)
        ctx.fillStyle = '#a00';
        // Left Eye
        ctx.beginPath();
        ctx.ellipse(-50, -20, 40, 50, -0.2, 0, Math.PI*2);
        ctx.fill();
        // Right Eye
        ctx.beginPath();
        ctx.ellipse(50, -20, 40, 50, 0.2, 0, Math.PI*2);
        ctx.fill();

        // Eye Highlights (Compound grid illusion)
        ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
        ctx.beginPath();
        ctx.ellipse(-50, -20, 30, 40, -0.2, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(50, -20, 30, 40, 0.2, 0, Math.PI*2);
        ctx.fill();

        // Proboscis
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.moveTo(-10, 60);
        ctx.quadraticCurveTo(0, 120, -20, 140);
        ctx.lineTo(20, 140);
        ctx.quadraticCurveTo(0, 120, 10, 60);
        ctx.fill();
        
        // Sucker
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.ellipse(0, 140, 20, 10, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }

    function drawBackground() {
        const tileSize = 50;
        const rows = Math.ceil(canvas.height / tileSize);
        const cols = Math.ceil(canvas.width / tileSize);

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#ffcccc'; // Light red
        
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if ((r + c) % 2 === 0) {
                    ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);
                }
            }
        }

        // Frozen overlay effect
        if (freezeTimer > 0) {
            ctx.fillStyle = 'rgba(135, 206, 250, 0.2)';
            ctx.fillRect(0,0, canvas.width, canvas.height);
        }
    }

    function loop() {
        frames++;

        if (gameState === 'START') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawStartScreenFly();
            requestAnimationFrame(loop);
            return;
        }

        if (gameState !== 'PLAYING') return;

        // Modifiers
        if (freezeTimer > 0) freezeTimer--;

        // Timer
        let elapsed = (Date.now() - startTime) / 1000;
        timerDisplay.innerText = elapsed.toFixed(1);

        // Update UI
        scoreDisplay.innerText = score;
        annoyanceBar.style.width = annoyance + '%';
        
        // Annoyance Check
        if (annoyance >= MAX_ANNOYANCE) {
            endGame();
            return;
        }

        // Spawn Logic
        const spawnRate = Math.max(15, 100 - (score * 2)); 
        if (frames % spawnRate === 0) {
            flies.push(new Fly());
        }

        // Bonus Spawn Logic (Rare)
        if (frames % 600 === 0 && Math.random() < 0.7) { // Every ~10 seconds
            bonuses.push(new Bonus());
        }

        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();

        // Update & Draw Splatters (Background layer)
        for (let i = splatters.length - 1; i >= 0; i--) {
            splatters[i].update();
            splatters[i].draw(ctx);
            if (splatters[i].life <= 0) splatters.splice(i, 1);
        }

        // Update & Draw Bonuses
        for (let i = bonuses.length - 1; i >= 0; i--) {
            bonuses[i].update();
            bonuses[i].draw(ctx);
            if (!bonuses[i].active) bonuses.splice(i, 1);
        }

        // Update & Draw Flies
        for (let i = flies.length - 1; i >= 0; i--) {
            flies[i].update();
            flies[i].draw(ctx);
        }
        
        // Hand Logic & Collision
        hand.update();

        // Remove dead flies
        flies = flies.filter(f => !f.isDead);

        // Update & Draw Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw(ctx);
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // Draw Hand (Foreground)
        hand.draw(ctx);

        requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.addEventListener('click', () => {
        startGame();
        loop(); // Start loop logic
    });
    restartBtn.addEventListener('click', () => {
        startGame();
        loop();
    });
    winRestartBtn.addEventListener('click', () => {
        startGame();
        loop();
    });

    // Start Animation Loop Immediately for Cover Art
    loop();

</script>
<script src="/game-wrapper.js"></script>
</body>
</html>