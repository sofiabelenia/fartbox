<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maggu's Fly Swat</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #333;
            font-family: 'Fredoka One', cursive;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: none;
        }

        /* UI Overlay Styles */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 20;
        }

        .hud-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-box, .timer-box {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 15px;
            border: 3px solid #ff6b6b;
            color: #ff6b6b;
            font-size: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .meter-container {
            width: 200px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 15px;
            border: 3px solid #ff6b6b;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .meter-label {
            color: #ff6b6b;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .meter-bar-bg {
            width: 100%;
            height: 20px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ade80, #facc15, #ef4444);
            transition: width 0.2s;
        }

        /* Menus */
        .menu {
            /* Make background slightly transparent to see the fly face */
            background: rgba(255, 255, 255, 0.85);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            border: 5px solid #ff6b6b;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            pointer-events: auto;
            max-width: 90%;
            width: 400px;
            backdrop-filter: blur(5px);
        }

        h1 {
            color: #ff6b6b;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 2px 2px 0px #ffe66d;
        }

        p {
            color: #333;
            font-size: 18px;
            line-height: 1.5;
            margin-bottom: 30px;
            font-weight: bold;
        }

        button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 5px 0 #e04f4f;
        }

        button:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #e04f4f;
        }

        button:hover {
            background: #ff5252;
        }

        .hidden {
            display: none !important;
        }

        /* Floating text for combos */
        .floating-text {
            position: absolute;
            color: #ff6b6b;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            z-index: 15;
        }
        
        /* Weapon unlock notification */
        .unlock-text {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #ff6b6b;
            font-weight: bold;
            font-size: 40px;
            pointer-events: none;
            text-shadow: 3px 3px 0 #fff;
            animation: popIn 2s ease-out forwards;
            z-index: 100;
        }

        /* Screen flash for Nuke */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.1s;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
        
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <canvas id="handCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;"></canvas>
    <div id="flash-overlay"></div>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
        <div class="hud-left">
            <div class="score-box">Score: <span id="scoreDisplay">0</span> / 1000</div>
            <div class="timer-box">Time: <span id="timerDisplay">0.0</span>s</div>
        </div>
        <div class="meter-container">
            <div class="meter-label">ANNOYANCE LEVEL</div>
            <div class="meter-bar-bg">
                <div id="annoyanceBar" class="meter-fill"></div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-layer" style="justify-content: flex-start; padding-top: 30px; pointer-events: none;">
        <h1 style="font-size: 42px; color: #ff4444; text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000; margin: 0;">MAGGU<br><span style="font-size: 28px;">vs</span><br>MOSCAS</h1>
        <div style="flex-grow: 1;"></div>
        <div id="playBtnContainer" style="margin-bottom: 50px;">
            <div id="playBtn" style="font-size: 36px; padding: 20px 80px; background: #ff4444; box-shadow: 0 8px 0 #aa0000; font-family: 'Fredoka One', cursive; border: none; color: white; border-radius: 50px; display: inline-block;">PLAY</div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="ui-layer hidden">
        <div class="menu">
            <h1>Game Over!</h1>
            <p>Maggu got too annoyed and left.</p>
            <p>Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">TRY AGAIN</button>
        </div>
    </div>

    <!-- Win Screen -->
    <div id="winScreen" class="ui-layer hidden">
        <div class="menu">
            <h1>PICNIC SAVED!</h1>
            <p>You cleared the swarm!</p>
            <p style="font-size: 24px; color: #4ade80;">Time: <span id="finalTime">0.0</span>s</p>
            <button id="winRestartBtn">PLAY AGAIN</button>
        </div>
    </div>
</div>

<script>
    /**
     * Game Configuration & State
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Hand canvas (on top of everything)
    const handCanvas = document.getElementById('handCanvas');
    const handCtx = handCanvas.getContext('2d');

    // UI Elements
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const winScreen = document.getElementById('winScreen');
    const hud = document.getElementById('hud');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const timerDisplay = document.getElementById('timerDisplay');
    const finalScoreDisplay = document.getElementById('finalScore');
    const finalTimeDisplay = document.getElementById('finalTime');
    const annoyanceBar = document.getElementById('annoyanceBar');
    const playBtn = document.getElementById('playBtn');
    const restartBtn = document.getElementById('restartBtn');
    const winRestartBtn = document.getElementById('winRestartBtn');
    const flashOverlay = document.getElementById('flash-overlay');

    // Game State
    let gameState = 'START'; // START, PLAYING, GAMEOVER, WIN
    let score = 0;
    let kills = 0;
    let frames = 0;
    let annoyance = 0;
    let startTime = 0;
    let currentTime = 0;
    const MAX_ANNOYANCE = 100;
    const TARGET_SCORE = 1000;
    
    // Modifiers
    let freezeTimer = 0;
    let timeWarpFactor = 1; // For Time Fly boss
    let screenShake = { x: 0, y: 0, intensity: 0 };

    // Hand Debuffs
    let handDebuffs = {
        shaky: 0,        // Timer for shakiness
        inverted: 0,     // Timer for inverted controls
        delayed: 0,      // Timer for delayed reactions
        delayBuffer: []  // Buffer for delayed input
    };

    // Audio Context for procedural sounds
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    function playBuzz(panic = false) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(panic ? 300 : 150, audioCtx.currentTime);
        if (panic) {
            osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
        }
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
    }

    function playThwack(heavy = false) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'square';
        osc.frequency.setValueAtTime(heavy ? 80 : 150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(heavy ? 30 : 50, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(heavy ? 0.3 : 0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.15);
    }

    function playZap() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sawtooth';
        for (let i = 0; i < 5; i++) {
            osc.frequency.setValueAtTime(800 + Math.random() * 400, audioCtx.currentTime + i * 0.02);
        }
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function playBossRoar() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    }

    function triggerScreenShake(intensity) {
        screenShake.intensity = intensity;
    }

    // Continuous buzz sound system
    let buzzOscillators = [];
    let buzzGainNode = null;
    let buzzLfoNode = null;

    function initBuzzSystem() {
        if (!audioCtx || buzzGainNode) return;

        // Master gain for all buzzing
        buzzGainNode = audioCtx.createGain();
        buzzGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        buzzGainNode.connect(audioCtx.destination);

        // LFO for wobble effect
        buzzLfoNode = audioCtx.createOscillator();
        buzzLfoNode.type = 'sine';
        buzzLfoNode.frequency.setValueAtTime(8, audioCtx.currentTime);

        // Create multiple oscillators for richer buzz
        const frequencies = [120, 180, 240];
        frequencies.forEach(freq => {
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

            // Connect LFO to frequency for wobble
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.setValueAtTime(10, audioCtx.currentTime);
            buzzLfoNode.connect(lfoGain);
            lfoGain.connect(osc.frequency);

            oscGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            osc.connect(oscGain);
            oscGain.connect(buzzGainNode);
            osc.start();
            buzzOscillators.push(osc);
        });

        buzzLfoNode.start();
    }

    function updateBuzzVolume() {
        if (!buzzGainNode || !audioCtx) return;

        // Count flies on screen
        const flyCount = flies.filter(f => !f.isDead && f.x > 0 && f.x < canvas.width && f.y > 0 && f.y < canvas.height).length;

        // Volume scales with fly count (0 flies = silent, 20+ flies = max volume)
        const targetVolume = Math.min(flyCount / 15, 1) * 0.12;

        // Smooth transition
        buzzGainNode.gain.linearRampToValueAtTime(targetVolume, audioCtx.currentTime + 0.1);

        // Adjust LFO speed based on fly count (more flies = more frantic)
        if (buzzLfoNode) {
            buzzLfoNode.frequency.linearRampToValueAtTime(5 + flyCount * 0.5, audioCtx.currentTime + 0.1);
        }
    }

    function stopBuzzSystem() {
        if (buzzGainNode) {
            buzzGainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        }
    }

    // Mouse/Touch Input
    const input = { x: 0, y: 0, isDown: false, clickHandled: false };

    // Entities
    let flies = [];
    let splatters = [];
    let particles = [];
    let bonuses = [];
    let hand = null;
    let menuHand = null;

    // Resizing
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        handCanvas.width = window.innerWidth;
        handCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    /**
     * Utilities
     */
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    function createFloatingText(text, x, y, isUnlock = false, color = '#ff6b6b') {
        const el = document.createElement('div');
        if (isUnlock) {
            el.className = 'unlock-text';
            el.style.top = '20%';
            el.style.left = '0';
        } else {
            el.className = 'floating-text';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
        }
        el.innerText = text;
        el.style.color = color;
        document.getElementById('game-container').appendChild(el);
        setTimeout(() => el.remove(), isUnlock ? 2000 : 1000);
    }

    function triggerFlash() {
        flashOverlay.style.opacity = 1;
        setTimeout(() => {
            flashOverlay.style.opacity = 0;
        }, 100);
    }

    /**
     * Classes
     */
    class Bonus {
        constructor() {
            this.x = randomRange(50, canvas.width - 50);
            this.y = randomRange(50, canvas.height - 50);
            // 50/50 Chance for Freeze or Nuke
            this.type = Math.random() < 0.5 ? 'FREEZE' : 'NUKE';
            this.life = 300; // 5 seconds (at 60fps) to grab it
            this.scale = 0;
            this.active = true;
            this.wobble = Math.random() * 10;
        }

        update() {
            // Pop in
            if (this.scale < 1) this.scale += 0.1;
            
            // Drift slightly
            this.y += Math.sin(this.wobble) * 0.5;
            this.wobble += 0.05;

            this.life--;
            // Flicker when dying
            if (this.life < 60 && this.life % 10 < 5) {
                // Invisible for flicker effect
            } 
            
            if (this.life <= 0) {
                this.active = false;
            }
        }

        draw(ctx) {
            if (this.life < 60 && this.life % 10 < 5) return;

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale, this.scale);

            // Glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.type === 'FREEZE' ? '#4deeea' : '#ff4757';

            // Orb
            let grad = ctx.createRadialGradient(0,0,5, 0,0,25);
            if (this.type === 'FREEZE') {
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.5, '#4deeea');
                grad.addColorStop(1, '#00b8d4');
            } else {
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.5, '#ff6b6b');
                grad.addColorStop(1, '#c0392b');
            }
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI*2);
            ctx.fill();

            // Icon
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowBlur = 0;
            ctx.fillText(this.type === 'FREEZE' ? 'â„ï¸' : 'ðŸ”¥', 0, 2);

            ctx.restore();
        }
    }

    class Hand {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.targetX = this.x;
            this.targetY = this.y;
            this.angle = 0;
            this.scale = 1;
            this.slapState = 'IDLE'; // IDLE, SLAPPING, RECOVERING
            this.slapTimer = 0;
            this.weapon = 'HAND'; // HAND, SWATTER, SPRAY, ZAPPER, GOLDEN
            this.wobble = 0; // For idle animation
        }

        getDamage() {
            switch(this.weapon) {
                case 'HAND': return 1;
                case 'SWATTER': return 2;
                case 'SPRAY': return 2; // Continuous/Wide
                case 'ZAPPER': return 5;
                case 'GOLDEN': return 100; // Insta-kill
                default: return 1;
            }
        }

        update() {
            this.wobble += 0.1;

            // Weapon Upgrade Logic
            if (kills >= 50 && this.weapon !== 'GOLDEN') {
                this.weapon = 'GOLDEN';
                createFloatingText("GOLDEN GAUNTLET UNLOCKED!", 0, 0, true);
            } else if (kills >= 30 && kills < 50 && this.weapon !== 'ZAPPER') {
                this.weapon = 'ZAPPER';
                createFloatingText("ELECTRIC RACKET UNLOCKED!", 0, 0, true);
            } else if (kills >= 15 && kills < 30 && this.weapon !== 'SPRAY') {
                this.weapon = 'SPRAY';
                createFloatingText("BUG SPRAY UNLOCKED!", 0, 0, true);
            } else if (kills >= 5 && kills < 15 && this.weapon !== 'SWATTER') {
                this.weapon = 'SWATTER';
                createFloatingText("SWATTER UNLOCKED!", 0, 0, true);
            }

            // Handle debuffs
            let inputX = input.x;
            let inputY = input.y;

            // Inverted controls
            if (handDebuffs.inverted > 0) {
                inputX = canvas.width - input.x;
                inputY = canvas.height - input.y;
                handDebuffs.inverted--;
            }

            // Delayed reactions - buffer input
            if (handDebuffs.delayed > 0) {
                handDebuffs.delayBuffer.push({ x: inputX, y: inputY });
                if (handDebuffs.delayBuffer.length > 15) {
                    const delayed = handDebuffs.delayBuffer.shift();
                    inputX = delayed.x;
                    inputY = delayed.y;
                }
                handDebuffs.delayed--;
                if (handDebuffs.delayed === 0) handDebuffs.delayBuffer = [];
            }

            // Smooth movement (LERP)
            this.targetX = inputX;
            this.targetY = inputY;

            let moveSpeed = 0.2;
            this.x += (this.targetX - this.x) * moveSpeed;
            this.y += (this.targetY - this.y) * moveSpeed;

            // Shakiness effect
            if (handDebuffs.shaky > 0) {
                this.x += randomRange(-8, 8);
                this.y += randomRange(-8, 8);
                handDebuffs.shaky--;
            }

            // Rotate based on velocity for dynamic feel
            const dx = this.targetX - this.x;
            this.angle = dx * 0.005;

            // Slap/Action Logic
            if (this.slapState === 'IDLE') {
                if (input.isDown && !input.clickHandled) {
                    this.slapState = 'SLAPPING';
                    this.slapTimer = 0;
                    input.clickHandled = true; // Consumed
                }
            } else if (this.slapState === 'SLAPPING') {
                this.slapTimer++;
                
                // Motion depends on weapon
                if (this.weapon === 'SPRAY') {
                     this.x += randomRange(-5, 5); // Shake
                } else if (this.weapon === 'ZAPPER') {
                    this.x += randomRange(-2, 2); // Electrical hum vibrate
                    this.scale = 1 - (this.slapTimer / 5) * 0.1;
                } else if (this.weapon === 'GOLDEN') {
                    this.scale = 1.2 - (this.slapTimer / 5) * 0.1; // Big smash
                } else {
                     this.scale = 1 - (this.slapTimer / 5) * 0.2; 
                }
                
                if (this.slapTimer >= 5) {
                    // HIT MOMENT
                    this.checkHit();
                    this.slapState = 'RECOVERING';
                    this.slapTimer = 0;
                }
            } else if (this.slapState === 'RECOVERING') {
                this.slapTimer++;
                // Bounce back up
                if (this.weapon !== 'SPRAY') {
                    let recoverSpeed = this.weapon === 'GOLDEN' ? 0.05 : 0.2;
                    this.scale += recoverSpeed;
                }
                if (this.slapTimer >= 10) {
                    this.scale = this.weapon === 'GOLDEN' ? 1.2 : 1;
                    this.slapState = 'IDLE';
                }
            }
        }

        checkHit() {
            let hitRadius = 50;
            let hitX = this.x;
            let hitY = this.y - 10;
            let particleColor = '#fff';

            // Weapon Configs
            if (this.weapon === 'SWATTER') {
                hitRadius = 90; 
                hitY = this.y - 80;
                particleColor = '#ccc';
            } else if (this.weapon === 'SPRAY') {
                hitRadius = 130; 
                hitY = this.y - 90;
                particleColor = '#80ff80'; 
                // Spawn gas
                for(let i=0; i<20; i++) {
                     particles.push(new Particle(hitX + randomRange(-40, 40), hitY + randomRange(-40, 40), '#a3ffac', randomRange(5, 15), 0.5));
                }
            } else if (this.weapon === 'ZAPPER') {
                hitRadius = 110;
                hitY = this.y - 100;
                particleColor = '#4deeea';
                // Electric sparks
                for(let i=0; i<15; i++) {
                     particles.push(new Particle(hitX + randomRange(-40, 40), hitY + randomRange(-40, 40), '#fff', randomRange(2, 6), 0, true));
                }
            } else if (this.weapon === 'GOLDEN') {
                hitRadius = 300; // Screen wipe almost
                hitY = this.y;
                particleColor = '#ffd700';
                // Holy blast
                for(let i=0; i<30; i++) {
                     particles.push(new Particle(hitX, hitY, '#ffd700', randomRange(5, 20), 0, false, 20));
                }
            }

            // Visual feedback
            if (this.weapon !== 'SPRAY') {
                for(let i=0; i<5; i++) {
                    particles.push(new Particle(hitX, hitY, particleColor, 3));
                }
            }

            // --- CHECK BONUS COLLISIONS ---
            for (let i = bonuses.length - 1; i >= 0; i--) {
                const b = bonuses[i];
                const dx = b.x - hitX;
                const dy = b.y - hitY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < hitRadius) {
                    // Activate Bonus
                    if (b.type === 'FREEZE') {
                        freezeTimer = 300; // 5 seconds
                        createFloatingText("â„ï¸ FROZEN! â„ï¸", b.x, b.y, false, '#4deeea');
                    } else if (b.type === 'NUKE') {
                        triggerFlash();
                        createFloatingText("ðŸ”¥ BOOM! ðŸ”¥", b.x, b.y, false, '#ff4757');
                        // Kill all flies
                        flies.forEach(f => f.die(true, true)); // Reuse 'holy' visual for nuke
                        kills += flies.length;
                        score += flies.length * 2;
                        flies = []; // Clear array
                    }
                    bonuses.splice(i, 1);
                }
            }

            // --- CHECK FLY COLLISIONS ---
            let hitCount = 0;
            const dmg = this.getDamage();

            for (let i = flies.length - 1; i >= 0; i--) {
                const fly = flies[i];
                const dx = fly.x - hitX;
                const dy = fly.y - hitY;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < hitRadius) { // Standard collision
                    fly.takeDamage(dmg, this.weapon);
                    if (fly.isDead) {
                        hitCount++;
                    } else {
                        // Feedback for hitting big fly but not killing
                         createFloatingText("HIT!", fly.x, fly.y - 30);
                         fly.hitFlash = 5; // Frames to flash white
                    }
                }
            }

            if (hitCount > 0) {
                kills += hitCount;
                let bonus = 1;
                if (this.weapon === 'SPRAY') bonus = 2;
                if (this.weapon === 'ZAPPER') bonus = 3;
                if (this.weapon === 'GOLDEN') bonus = 5;

                score += hitCount * bonus;

                // Play sound based on weapon
                if (this.weapon === 'ZAPPER') {
                    playZap();
                } else if (this.weapon === 'GOLDEN') {
                    playThwack(true);
                    triggerScreenShake(15);
                } else {
                    playThwack(this.weapon === 'SWATTER');
                    triggerScreenShake(this.weapon === 'SWATTER' ? 5 : 3);
                }

                if (hitCount > 1) {
                    createFloatingText("COMBO x" + hitCount + "!", this.x, this.y - 50);
                }
                
                // Reduce annoyance significantly on kills
                annoyance = Math.max(0, annoyance - (5 * hitCount));

                // Win Condition Check
                if (score >= TARGET_SCORE) {
                    winGame();
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.scale(this.scale, this.scale);

            // Arm/Hand Common Settings
            let skinColor = '#fce4d4';
            let shadowColor = '#eebb99';
            let nailColor = '#ff6b81';
            let braceletColor = '#ffd700';

            if (this.weapon === 'GOLDEN') {
                skinColor = '#ffd700';
                shadowColor = '#d4af37';
                nailColor = '#fff';
                braceletColor = '#fff';
                
                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffd700';
            } else {
                ctx.shadowBlur = 0;
            }

            // --- DRAW ARM ---
            // Gradient for arm roundness
            let armGrad = ctx.createLinearGradient(-20, 0, 20, 0);
            armGrad.addColorStop(0, shadowColor);
            armGrad.addColorStop(0.3, skinColor);
            armGrad.addColorStop(0.8, skinColor);
            armGrad.addColorStop(1, shadowColor);

            ctx.fillStyle = armGrad;
            ctx.beginPath();
            ctx.moveTo(-15, 100);
            ctx.lineTo(15, 100);
            ctx.lineTo(12, 250); // Longer arm offscreen
            ctx.lineTo(-12, 250);
            ctx.fill();

            // Wrist Accessory
            ctx.fillStyle = braceletColor;
            ctx.fillRect(-16, 90, 32, 8);
            if(this.weapon !== 'GOLDEN') {
                ctx.fillStyle = '#ffec8b';
                ctx.fillRect(-16, 92, 32, 2);
            }

            if (this.weapon === 'HAND' || this.weapon === 'GOLDEN') {
                this.drawBeautifulHand(ctx, skinColor, shadowColor, nailColor);
            } else if (this.weapon === 'SWATTER') {
                this.drawHandHoldingSwatter(ctx, skinColor, shadowColor, nailColor);
            } else if (this.weapon === 'SPRAY') {
                this.drawHandHoldingSpray(ctx, skinColor, shadowColor, nailColor);
            } else if (this.weapon === 'ZAPPER') {
                this.drawHandHoldingZapper(ctx, skinColor, shadowColor, nailColor);
            }

            ctx.restore();
        }

        drawBeautifulHand(ctx, skin, shadow, nail) {
            // Palm - more delicate oval shape
            let palmGrad = ctx.createRadialGradient(0, 40, 5, 0, 40, 50);
            palmGrad.addColorStop(0, skin);
            palmGrad.addColorStop(1, shadow);
            ctx.fillStyle = palmGrad;
            ctx.beginPath();
            ctx.ellipse(0, 45, 32, 40, 0, 0, Math.PI * 2);
            ctx.fill();

            // Slender feminine fingers - longer and thinner
            const fingers = [
                {x: -25, y: 5, w: 11, h: 55, ang: -0.15},   // Pinky
                {x: -9, y: -15, w: 12, h: 72, ang: -0.08},  // Ring finger
                {x: 9, y: -18, w: 12, h: 78, ang: 0},       // Middle finger
                {x: 25, y: -8, w: 11, h: 65, ang: 0.1}      // Index finger
            ];

            fingers.forEach((f, idx) => {
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.ang);

                // Finger with gradient for roundness
                let fingerGrad = ctx.createLinearGradient(-f.w/2, 0, f.w/2, 0);
                fingerGrad.addColorStop(0, shadow);
                fingerGrad.addColorStop(0.3, skin);
                fingerGrad.addColorStop(0.7, skin);
                fingerGrad.addColorStop(1, shadow);
                ctx.fillStyle = fingerGrad;

                // Smoother, tapered finger shape
                ctx.beginPath();
                ctx.moveTo(-f.w/2, 0);
                ctx.quadraticCurveTo(-f.w/2 - 1, -f.h * 0.5, -f.w/2 + 2, -f.h + 8);
                ctx.quadraticCurveTo(0, -f.h - 3, f.w/2 - 2, -f.h + 8);
                ctx.quadraticCurveTo(f.w/2 + 1, -f.h * 0.5, f.w/2, 0);
                ctx.fill();

                // Knuckle subtle highlight
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.beginPath();
                ctx.ellipse(0, -f.h * 0.3, f.w/3, 4, 0, 0, Math.PI*2);
                ctx.fill();

                // Elegant almond-shaped nail with gradient
                let nailGrad = ctx.createLinearGradient(0, -f.h + 12, 0, -f.h - 5);
                nailGrad.addColorStop(0, nail);
                nailGrad.addColorStop(0.5, '#ff8fa3');
                nailGrad.addColorStop(1, '#ffb6c1');
                ctx.fillStyle = nailGrad;
                ctx.beginPath();
                // Almond shape - pointed tip
                ctx.moveTo(-f.w/3, -f.h + 12);
                ctx.quadraticCurveTo(-f.w/3 - 1, -f.h + 2, 0, -f.h - 8);
                ctx.quadraticCurveTo(f.w/3 + 1, -f.h + 2, f.w/3, -f.h + 12);
                ctx.quadraticCurveTo(0, -f.h + 10, -f.w/3, -f.h + 12);
                ctx.fill();

                // Nail shine
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.beginPath();
                ctx.ellipse(-1, -f.h + 2, 2, 5, 0.1, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            });

            // Elegant thumb
            ctx.save();
            ctx.translate(33, 55);
            ctx.rotate(0.5);

            // Thumb gradient
            let thumbGrad = ctx.createLinearGradient(-7, 0, 7, 0);
            thumbGrad.addColorStop(0, shadow);
            thumbGrad.addColorStop(0.3, skin);
            thumbGrad.addColorStop(0.7, skin);
            thumbGrad.addColorStop(1, shadow);
            ctx.fillStyle = thumbGrad;

            ctx.beginPath();
            ctx.moveTo(-7, 0);
            ctx.quadraticCurveTo(-8, -25, -6, -42);
            ctx.quadraticCurveTo(0, -50, 6, -42);
            ctx.quadraticCurveTo(8, -25, 7, 0);
            ctx.fill();

            // Thumb nail - almond shape
            let thumbNailGrad = ctx.createLinearGradient(0, -35, 0, -48);
            thumbNailGrad.addColorStop(0, nail);
            thumbNailGrad.addColorStop(0.5, '#ff8fa3');
            thumbNailGrad.addColorStop(1, '#ffb6c1');
            ctx.fillStyle = thumbNailGrad;
            ctx.beginPath();
            ctx.moveTo(-5, -35);
            ctx.quadraticCurveTo(-5, -42, 0, -48);
            ctx.quadraticCurveTo(5, -42, 5, -35);
            ctx.quadraticCurveTo(0, -34, -5, -35);
            ctx.fill();

            // Thumb nail shine
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.ellipse(-1, -40, 1.5, 4, 0.1, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

        drawHandHoldingSwatter(ctx, skin, shadow, nail) {
             // Handle Stick
             ctx.fillStyle = '#555';
             ctx.fillRect(-5, -50, 10, 150);

             // Swatter Head
             ctx.save();
             ctx.translate(0, -120);
             ctx.fillStyle = 'rgba(255, 100, 100, 0.4)';
             ctx.fillRect(-45, -45, 90, 90);
             ctx.strokeStyle = '#d00';
             ctx.lineWidth = 2;
             ctx.strokeRect(-45, -45, 90, 90);
             ctx.beginPath();
             for(let i=-35; i<45; i+=15) {
                 ctx.moveTo(i, -45); ctx.lineTo(i, 45);
                 ctx.moveTo(-45, i); ctx.lineTo(45, i);
             }
             ctx.stroke();
             ctx.restore();

             this.drawCurledFingers(ctx, skin, nail);
        }

        drawHandHoldingZapper(ctx, skin, shadow, nail) {
            // Handle
            ctx.fillStyle = '#222';
            ctx.fillRect(-8, -50, 16, 150);

            // Zapper Head (Tennis racket style)
            ctx.save();
            ctx.translate(0, -130);
            
            // Outer Frame
            ctx.fillStyle = '#facc15'; // Yellow plastic
            ctx.beginPath();
            ctx.ellipse(0, 0, 55, 70, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#222'; // Inner hole
            ctx.beginPath();
            ctx.ellipse(0, 0, 45, 60, 0, 0, Math.PI*2);
            ctx.fill();

            // Electric Grid
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=-40; i<40; i+=8) {
                ctx.moveTo(i, -50); ctx.lineTo(i, 50); // Vertical
                ctx.moveTo(-40, i*1.2); ctx.lineTo(40, i*1.2); // Horiz
            }
            ctx.stroke();

            // Arcs (Animation)
            if (frames % 10 < 5) {
                ctx.strokeStyle = '#4deeea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-20, -20); ctx.lineTo(20, 20);
                ctx.moveTo(20, -20); ctx.lineTo(-20, 20);
                ctx.stroke();
            }

            ctx.restore();
            this.drawCurledFingers(ctx, skin, nail);
        }

        drawHandHoldingSpray(ctx, skin, shadow, nail) {
            ctx.save();
            ctx.translate(0, -50);
            let canGrad = ctx.createLinearGradient(-25, 0, 25, 0);
            canGrad.addColorStop(0, '#004d00');
            canGrad.addColorStop(0.5, '#00b300');
            canGrad.addColorStop(1, '#004d00');
            ctx.fillStyle = canGrad;
            ctx.fillRect(-25, -60, 50, 140);
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.arc(0, -60, 24, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = 'red';
            ctx.fillRect(-5, -84, 10, 10);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.fillText("TOXIC", -18, 0);
            ctx.restore();

             ctx.fillStyle = skin;
             ctx.beginPath();
             ctx.ellipse(10, 60, 30, 40, 0, 0, Math.PI*2);
             ctx.fill();

             ctx.beginPath();
             ctx.moveTo(15, 30);
             ctx.lineTo(5, -120); 
             ctx.lineWidth = 14;
             ctx.strokeStyle = skin;
             ctx.lineCap = 'round';
             ctx.stroke();
             
             ctx.fillStyle = nail;
             ctx.beginPath();
             ctx.ellipse(5, -125, 5, 6, 0, 0, Math.PI*2);
             ctx.fill();

             for(let i=0; i<3; i++) {
                 ctx.beginPath();
                 ctx.ellipse(25, 20 + (i*15), 18, 8, 0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = nail;
                 ctx.beginPath();
                 ctx.ellipse(35, 20 + (i*15), 4, 6, 0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = skin;
             }
        }

        drawCurledFingers(ctx, skin, nail) {
             // Delicate palm grip
             ctx.fillStyle = skin;
             ctx.beginPath();
             ctx.ellipse(0, 50, 30, 32, 0, 0, Math.PI * 2);
             ctx.fill();

             // More elegant curled fingers
             const knuckles = [-22, -7, 7, 22];
             knuckles.forEach((kx, i) => {
                 ctx.fillStyle = skin;
                 ctx.beginPath();
                 ctx.ellipse(kx, 28 - Math.abs(kx)*0.1, 8, 10, 0, 0, Math.PI*2);
                 ctx.fill();

                 // Almond nails with gradient
                 let nailGrad = ctx.createLinearGradient(kx, 32, kx, 38);
                 nailGrad.addColorStop(0, nail);
                 nailGrad.addColorStop(1, '#ffb6c1');
                 ctx.fillStyle = nailGrad;
                 ctx.beginPath();
                 ctx.ellipse(kx, 32 - Math.abs(kx)*0.1, 5, 6, 0, 0, Math.PI*2);
                 ctx.fill();

                 // Nail shine
                 ctx.fillStyle = 'rgba(255,255,255,0.5)';
                 ctx.beginPath();
                 ctx.ellipse(kx - 1, 30 - Math.abs(kx)*0.1, 1.5, 2, 0, 0, Math.PI*2);
                 ctx.fill();
             });
        }
    }

    class Fly {
        constructor() {
            // Big Fly Logic
            this.isBig = Math.random() < 0.05; // 5% chance spawn
            this.hp = this.isBig ? 5 : 1;
            this.scaleMult = this.isBig ? 2.5 : 1;

            if (Math.random() < 0.5) {
                this.x = Math.random() < 0.5 ? -20 : canvas.width + 20;
                this.y = Math.random() * canvas.height;
            } else {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() < 0.5 ? -20 : canvas.height + 20;
            }
            
            let baseSpeed = randomRange(3, 6 + (score / 20));
            if (this.isBig) baseSpeed *= 0.5; // Big flies are slower

            this.vx = randomRange(-2, 2);
            this.vy = randomRange(-2, 2);
            this.speed = baseSpeed;
            this.angle = 0;
            this.wingState = 0;
            this.targetX = Math.random() * canvas.width;
            this.targetY = Math.random() * canvas.height;
            this.changeDirTimer = 0;
            this.isDead = false;
            this.hitFlash = 0;
        }

        takeDamage(amount, weaponType) {
            this.hp -= amount;
            if (this.hp <= 0) {
                let zapped = weaponType === 'ZAPPER';
                let holy = weaponType === 'GOLDEN' || weaponType === 'NUKE'; // Nuke uses holy effect
                this.die(zapped, holy);
            }
        }

        update() {
            if (this.isDead) return;

            // FREEZE LOGIC
            if (freezeTimer > 0) {
                // Just jitter
                this.x += randomRange(-0.5, 0.5);
                this.y += randomRange(-0.5, 0.5);
                this.wingState += 0.2; // Slow wings
                return;
            }

            this.changeDirTimer--;
            if (this.changeDirTimer <= 0) {
                this.targetX = Math.random() * canvas.width;
                this.targetY = Math.random() * canvas.height;
                this.changeDirTimer = randomRange(30, 100);
            }

            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 0) {
                this.vx += (dx / dist) * 0.5;
                this.vy += (dy / dist) * 0.5;
            }

            const velocity = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
            if (velocity > this.speed) {
                this.vx = (this.vx / velocity) * this.speed;
                this.vy = (this.vy / velocity) * this.speed;
            }

            this.x += this.vx + randomRange(-2, 2);
            this.y += this.vy + randomRange(-2, 2);
            this.angle = Math.atan2(this.vy, this.vx);
            this.wingState += 1;

            if (this.x > 0 && this.x < canvas.width && this.y > 0 && this.y < canvas.height) {
                annoyance += this.isBig ? 0.06 : 0.03; // Big flies annoy more
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scaleMult, this.scaleMult);
            ctx.rotate(this.angle + Math.PI/2);

            // Hit Flash
            if (this.hitFlash > 0) {
                ctx.globalCompositeOperation = 'source-over'; // Normal
                // Could use overlay but simpler to just tint
                this.hitFlash--;
            }

            // Wings
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const wingOffset = Math.sin(this.wingState) * 5;
            ctx.beginPath();
            ctx.ellipse(-8 - wingOffset, 5, 8, 12, -0.5, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8 + wingOffset, 5, 8, 12, 0.5, 0, Math.PI*2);
            ctx.fill();

            // Body
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#222';
            ctx.beginPath();
            ctx.ellipse(0, 0, 6, 10, 0, 0, Math.PI*2);
            ctx.fill();

            // Eyes (Red)
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#d00';
            ctx.beginPath();
            ctx.arc(-3, -6, 3, 0, Math.PI*2);
            ctx.arc(3, -6, 3, 0, Math.PI*2);
            ctx.fill();
            
            // Big Fly Details (Crown/Spikes)
            if (this.isBig) {
                 ctx.fillStyle = '#f1c40f';
                 ctx.beginPath();
                 ctx.moveTo(-4, -10); ctx.lineTo(-2, -15); ctx.lineTo(0, -10); ctx.lineTo(2, -15); ctx.lineTo(4, -10);
                 ctx.fill();
            }

            ctx.restore();
        }

        die(zapped = false, holy = false) {
            this.isDead = true;
            let scale = this.isBig ? 2 : 1;
            playBuzz(true); // Panic buzz on death

            // Reduce annoyance when fly is killed
            annoyance = Math.max(0, annoyance - (this.isBig ? 15 : 5));

            if (holy) {
                 splatters.push(new Splatter(this.x, this.y, '#ffd700', scale));
            } else if (zapped) {
                 splatters.push(new Splatter(this.x, this.y, '#222', scale)); // Ash mark
                 for(let i=0; i<8; i++) {
                    particles.push(new Particle(this.x, this.y, '#4deeea', randomRange(2,5), 0, true));
                }
            } else {
                 splatters.push(new Splatter(this.x, this.y, '#2d4a1c', scale));
                 for(let i=0; i<8; i++) {
                    particles.push(new Particle(this.x, this.y, '#5c1919', randomRange(2,5)));
                }
            }
        }
    }

    // ==================== BOSS FLY CLASSES ====================

    // THE QUEEN - Spawns minion eggs that hatch into flies
    class QueenFly {
        constructor() {
            this.x = Math.random() < 0.5 ? -50 : canvas.width + 50;
            this.y = canvas.height * 0.3 + Math.random() * canvas.height * 0.4;
            this.hp = 15;
            this.maxHp = 15;
            this.scaleMult = 3.5;
            this.speed = 1.5;
            this.vx = this.x < 0 ? 1 : -1;
            this.vy = 0;
            this.angle = 0;
            this.wingState = 0;
            this.isDead = false;
            this.hitFlash = 0;
            this.bossType = 'QUEEN';
            this.eggTimer = 0;
            this.eggs = []; // Track eggs spawned by this queen
            playBossRoar();
            createFloatingText("THE QUEEN APPROACHES!", canvas.width/2, 100, true, '#9b59b6');
        }

        update() {
            if (this.isDead) return;
            if (freezeTimer > 0) {
                this.wingState += 0.2;
                return;
            }

            // Slow hovering movement
            this.x += this.vx * this.speed * timeWarpFactor;
            this.y += Math.sin(frames * 0.02) * 1.5;
            this.wingState += 0.8;

            // Bounce off edges
            if (this.x < 50 || this.x > canvas.width - 50) this.vx *= -1;

            // Spawn eggs periodically
            this.eggTimer++;
            if (this.eggTimer > 180) { // Every 3 seconds
                this.eggTimer = 0;
                const egg = new QueenEgg(this.x, this.y + 30);
                this.eggs.push(egg);
                flies.push(egg);
            }

            // Attack hand if close
            if (hand) {
                const dx = hand.x - this.x;
                const dy = hand.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 80) {
                    // Bite! Apply debuff
                    handDebuffs.shaky = 90;
                    createFloatingText("BITTEN!", hand.x, hand.y - 50, false, '#9b59b6');
                    triggerScreenShake(10);
                }
            }

            annoyance += 0.08;
        }

        takeDamage(amount, weaponType) {
            this.hp -= amount;
            this.hitFlash = 8;
            triggerScreenShake(5);
            if (this.hp <= 0) {
                this.die(weaponType === 'ZAPPER', weaponType === 'GOLDEN');
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scaleMult, this.scaleMult);

            // Glow aura
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#9b59b6';

            // Wings (larger, more regal)
            ctx.fillStyle = 'rgba(200, 150, 255, 0.6)';
            const wingOffset = Math.sin(this.wingState) * 8;
            ctx.beginPath();
            ctx.ellipse(-12 - wingOffset, 5, 12, 18, -0.5, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(12 + wingOffset, 5, 12, 18, 0.5, 0, Math.PI*2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Body (purple, royal)
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#6b2d8b';
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 14, 0, 0, Math.PI*2);
            ctx.fill();

            // Stripes
            ctx.fillStyle = '#4a1d6b';
            for (let i = -8; i < 10; i += 4) {
                ctx.fillRect(-6, i, 12, 2);
            }

            // Crown
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.moveTo(-8, -12);
            ctx.lineTo(-6, -20);
            ctx.lineTo(-3, -14);
            ctx.lineTo(0, -22);
            ctx.lineTo(3, -14);
            ctx.lineTo(6, -20);
            ctx.lineTo(8, -12);
            ctx.closePath();
            ctx.fill();

            // Crown gems
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(0, -16, 2, 0, Math.PI*2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#e74c3c';
            ctx.beginPath();
            ctx.arc(-4, -6, 4, 0, Math.PI*2);
            ctx.arc(4, -6, 4, 0, Math.PI*2);
            ctx.fill();

            // HP Bar
            ctx.fillStyle = '#333';
            ctx.fillRect(-15, -30, 30, 4);
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(-15, -30, 30 * (this.hp / this.maxHp), 4);

            ctx.restore();
        }

        die(zapped, holy) {
            this.isDead = true;
            playBossRoar();
            triggerScreenShake(20);
            // Kill all eggs when queen dies
            this.eggs.forEach(egg => { if (!egg.isDead) egg.isDead = true; });
            splatters.push(new Splatter(this.x, this.y, '#9b59b6', 3));
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(this.x, this.y, '#9b59b6', randomRange(5, 15), 0, false, 15));
            }
            score += 50;
            createFloatingText("+50 QUEEN SLAIN!", this.x, this.y - 50, false, '#ffd700');
        }
    }

    // Queen's Egg - hatches into flies if not destroyed
    class QueenEgg {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.hp = 2;
            this.scaleMult = 1.5;
            this.isDead = false;
            this.hitFlash = 0;
            this.hatchTimer = 180; // 3 seconds to hatch
            this.wobble = 0;
            this.bossType = 'EGG';
        }

        update() {
            if (this.isDead) return;
            this.wobble += 0.2;
            this.x += Math.sin(this.wobble) * 0.5;

            this.hatchTimer--;
            if (this.hatchTimer <= 0) {
                // Hatch into 3 flies!
                for (let i = 0; i < 3; i++) {
                    const fly = new Fly();
                    fly.x = this.x + randomRange(-20, 20);
                    fly.y = this.y + randomRange(-20, 20);
                    flies.push(fly);
                }
                this.isDead = true;
                createFloatingText("HATCHED!", this.x, this.y, false, '#9b59b6');
            }
        }

        takeDamage(amount, weaponType) {
            this.hp -= amount;
            this.hitFlash = 5;
            if (this.hp <= 0) {
                this.isDead = true;
                splatters.push(new Splatter(this.x, this.y, '#ffffaa', 1));
                score += 5;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scaleMult, this.scaleMult);
            ctx.rotate(Math.sin(this.wobble * 2) * 0.1);

            // Egg shape
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#ffffcc';
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI*2);
            ctx.fill();

            // Pulsing glow when about to hatch
            if (this.hatchTimer < 60) {
                ctx.strokeStyle = `rgba(155, 89, 182, ${0.5 + Math.sin(this.wobble * 3) * 0.5})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();
        }
    }

    // THE MAGNET - Pulls the hand toward it
    class MagnetFly {
        constructor() {
            this.x = canvas.width / 2 + randomRange(-200, 200);
            this.y = canvas.height / 2 + randomRange(-100, 100);
            this.hp = 12;
            this.maxHp = 12;
            this.scaleMult = 3;
            this.isDead = false;
            this.hitFlash = 0;
            this.bossType = 'MAGNET';
            this.pulsePhase = 0;
            this.magnetStrength = 0;
            playBossRoar();
            createFloatingText("THE MAGNET APPEARS!", canvas.width/2, 100, true, '#3498db');
        }

        update() {
            if (this.isDead) return;
            if (freezeTimer > 0) return;

            this.pulsePhase += 0.1;

            // Slowly drift
            this.x += Math.sin(frames * 0.01) * 0.5;
            this.y += Math.cos(frames * 0.015) * 0.5;

            // Magnetic pull on hand
            if (hand) {
                const dx = this.x - hand.x;
                const dy = this.y - hand.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Stronger pull when closer, pulsing
                this.magnetStrength = (1 - Math.min(dist / 400, 1)) * (0.5 + Math.sin(this.pulsePhase) * 0.3);

                if (dist > 50) {
                    hand.x += (dx / dist) * this.magnetStrength * 8 * timeWarpFactor;
                    hand.y += (dy / dist) * this.magnetStrength * 8 * timeWarpFactor;
                }

                // Shock if too close
                if (dist < 60) {
                    handDebuffs.inverted = 120; // 2 seconds inverted
                    createFloatingText("MAGNETIZED!", hand.x, hand.y - 50, false, '#3498db');
                    triggerScreenShake(8);
                }
            }

            annoyance += 0.05;
        }

        takeDamage(amount, weaponType) {
            this.hp -= amount;
            this.hitFlash = 8;
            triggerScreenShake(5);
            if (this.hp <= 0) {
                this.die(weaponType === 'ZAPPER', weaponType === 'GOLDEN');
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scaleMult, this.scaleMult);

            // Magnetic field rings
            const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(52, 152, 219, ${pulse * 0.3})`;
            ctx.lineWidth = 2;
            for (let r = 20; r < 60; r += 15) {
                ctx.beginPath();
                ctx.arc(0, 0, r + Math.sin(this.pulsePhase + r) * 5, 0, Math.PI*2);
                ctx.stroke();
            }

            // Body (metallic blue)
            let bodyGrad = ctx.createRadialGradient(0, 0, 2, 0, 0, 12);
            bodyGrad.addColorStop(0, '#5dade2');
            bodyGrad.addColorStop(0.5, '#2980b9');
            bodyGrad.addColorStop(1, '#1a5276');
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 10, 14, 0, 0, Math.PI*2);
            ctx.fill();

            // Magnet poles (red and blue ends)
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(-8, 0, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(8, 0, 5, 0, Math.PI*2);
            ctx.fill();

            // N and S labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 6px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('N', -8, 2);
            ctx.fillText('S', 8, 2);

            // Eyes (electric)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-3, -8, 3, 0, Math.PI*2);
            ctx.arc(3, -8, 3, 0, Math.PI*2);
            ctx.fill();

            // HP Bar
            ctx.fillStyle = '#333';
            ctx.fillRect(-15, -25, 30, 4);
            ctx.fillStyle = '#3498db';
            ctx.fillRect(-15, -25, 30 * (this.hp / this.maxHp), 4);

            ctx.restore();

            // Draw pull line to hand
            if (hand && this.magnetStrength > 0.1) {
                ctx.strokeStyle = `rgba(52, 152, 219, ${this.magnetStrength})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(hand.x, hand.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        die(zapped, holy) {
            this.isDead = true;
            playZap();
            triggerScreenShake(15);
            splatters.push(new Splatter(this.x, this.y, '#3498db', 3));
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(this.x, this.y, '#3498db', randomRange(3, 10), 0, true));
            }
            score += 40;
            createFloatingText("+40 MAGNET DESTROYED!", this.x, this.y - 50, false, '#ffd700');
        }
    }

    // THE TIME FLY - Warps time around itself
    class TimeFly {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.hp = 10;
            this.maxHp = 10;
            this.scaleMult = 2.8;
            this.isDead = false;
            this.hitFlash = 0;
            this.bossType = 'TIME';
            this.clockAngle = 0;
            this.warpTimer = 0;
            this.speed = 4; // It's fast!
            this.vx = randomRange(-1, 1);
            this.vy = randomRange(-1, 1);
            playBossRoar();
            createFloatingText("TIME FLY DETECTED!", canvas.width/2, 100, true, '#f39c12');
        }

        update() {
            if (this.isDead) return;
            if (freezeTimer > 0) {
                this.clockAngle += 0.05;
                return;
            }

            this.clockAngle += 0.2;

            // Time warp effect - changes global time factor
            this.warpTimer++;
            if (this.warpTimer > 120) {
                this.warpTimer = 0;
                // Randomly speed up or slow down everything else
                timeWarpFactor = Math.random() < 0.5 ? 0.3 : 2.5;
                createFloatingText(timeWarpFactor < 1 ? "SLOW-MO!" : "FAST FORWARD!", this.x, this.y - 40, false, '#f39c12');
                setTimeout(() => { timeWarpFactor = 1; }, 2000);
            }

            // This fly moves at normal speed regardless of time warp
            this.x += this.vx * this.speed;
            this.y += this.vy * this.speed;

            // Bounce off walls
            if (this.x < 50 || this.x > canvas.width - 50) this.vx *= -1;
            if (this.y < 50 || this.y > canvas.height - 50) this.vy *= -1;

            // Random direction changes
            if (Math.random() < 0.02) {
                this.vx = randomRange(-1, 1);
                this.vy = randomRange(-1, 1);
            }

            // Touch causes delayed reactions
            if (hand) {
                const dx = hand.x - this.x;
                const dy = hand.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 70) {
                    handDebuffs.delayed = 180; // 3 seconds delay
                    createFloatingText("TIME LAGGED!", hand.x, hand.y - 50, false, '#f39c12');
                    triggerScreenShake(6);
                }
            }

            annoyance += 0.04;
        }

        takeDamage(amount, weaponType) {
            this.hp -= amount;
            this.hitFlash = 8;
            triggerScreenShake(4);
            if (this.hp <= 0) {
                this.die(weaponType === 'ZAPPER', weaponType === 'GOLDEN');
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scaleMult, this.scaleMult);

            // Time distortion effect (warped circles)
            ctx.strokeStyle = 'rgba(243, 156, 18, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate(this.clockAngle + i * 0.5);
                ctx.beginPath();
                ctx.ellipse(0, 0, 20 + i * 8, 15 + i * 5, 0, 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
            }

            // Body (golden/bronze)
            let bodyGrad = ctx.createRadialGradient(0, 0, 2, 0, 0, 12);
            bodyGrad.addColorStop(0, '#f9e79f');
            bodyGrad.addColorStop(0.5, '#f39c12');
            bodyGrad.addColorStop(1, '#935116');
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 10, 12, 0, 0, Math.PI*2);
            ctx.fill();

            // Clock face on body
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI*2);
            ctx.fill();

            // Clock hands
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(this.clockAngle) * 4, Math.sin(this.clockAngle) * 4);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(this.clockAngle * 0.1) * 3, Math.sin(this.clockAngle * 0.1) * 3);
            ctx.stroke();

            // Eyes
            ctx.fillStyle = this.hitFlash > 0 ? '#fff' : '#f39c12';
            ctx.beginPath();
            ctx.arc(-4, -8, 3, 0, Math.PI*2);
            ctx.arc(4, -8, 3, 0, Math.PI*2);
            ctx.fill();

            // HP Bar
            ctx.fillStyle = '#333';
            ctx.fillRect(-15, -22, 30, 4);
            ctx.fillStyle = '#f39c12';
            ctx.fillRect(-15, -22, 30 * (this.hp / this.maxHp), 4);

            ctx.restore();
        }

        die(zapped, holy) {
            this.isDead = true;
            timeWarpFactor = 1; // Reset time
            playBossRoar();
            triggerScreenShake(12);
            splatters.push(new Splatter(this.x, this.y, '#f39c12', 2.5));
            for (let i = 0; i < 12; i++) {
                particles.push(new Particle(this.x, this.y, '#f39c12', randomRange(3, 8), 0, false, 12));
            }
            score += 35;
            createFloatingText("+35 TIME RESTORED!", this.x, this.y - 50, false, '#ffd700');
        }
    }

    // Boss spawning helper
    let bossesSpawned = 0;
    let lastBossScore = 0;

    function trySpawnBoss() {
        // Spawn a boss every 200 points, max 3 on screen
        const activeBosses = flies.filter(f => f.bossType).length;
        if (score >= lastBossScore + 200 && activeBosses < 2) {
            lastBossScore = score;
            bossesSpawned++;
            const bossTypes = [QueenFly, MagnetFly, TimeFly];
            const BossClass = bossTypes[bossesSpawned % bossTypes.length];
            flies.push(new BossClass());
        }
    }

    class Splatter {
        constructor(x, y, color, scaleMult = 1) {
            this.x = x;
            this.y = y;
            this.alpha = 1;
            this.scale = randomRange(0.8, 1.5) * scaleMult;
            this.rotation = Math.random() * Math.PI * 2;
            this.life = 600;
            this.color = color;
        }

        update() {
            this.life--;
            if (this.life < 60) {
                this.alpha = this.life / 60;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale, this.scale);
            ctx.globalAlpha = this.alpha;

            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.bezierCurveTo(10, -15, 15, -5, 10, 0);
            ctx.bezierCurveTo(15, 10, 5, 15, 0, 10);
            ctx.bezierCurveTo(-10, 15, -15, 5, -10, 0);
            ctx.bezierCurveTo(-15, -10, -5, -15, 0, -10);
            ctx.fill();
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, size, driftSpeed = 0, electric = false, explodeSpeed = 0) {
            this.x = x;
            this.y = y;
            if (explodeSpeed > 0) {
                let ang = Math.random() * Math.PI * 2;
                let spd = Math.random() * explodeSpeed;
                this.vx = Math.cos(ang) * spd;
                this.vy = Math.sin(ang) * spd;
            } else {
                this.vx = randomRange(-5, 5);
                this.vy = randomRange(-5, 5);
            }
            this.color = color;
            this.size = size;
            this.life = 30;
            this.driftSpeed = driftSpeed;
            this.electric = electric;
        }

        update() {
            if (this.driftSpeed > 0) {
                this.x += this.vx * 0.2;
                this.y += this.vy * 0.2 - 1;
                this.size *= 1.02;
            } else {
                this.x += this.vx;
                this.y += this.vy;
                if (!this.electric) this.size *= 0.9;
            }
            this.life--;
        }

        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life / 30;
            ctx.beginPath();
            if (this.electric) {
                // Draw jagged line or square
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + randomRange(-5, 5), this.y + randomRange(-5,5));
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }

    /**
     * Input Handling
     */
    window.addEventListener('mousemove', e => {
        input.x = e.clientX;
        input.y = e.clientY;
    });

    window.addEventListener('touchmove', e => {
        e.preventDefault();
        input.x = e.touches[0].clientX;
        input.y = e.touches[0].clientY;
    }, {passive: false});

    window.addEventListener('mousedown', () => {
        input.isDown = true;
        input.clickHandled = false;
    });

    window.addEventListener('touchstart', (e) => {
        input.x = e.touches[0].clientX;
        input.y = e.touches[0].clientY;
        input.isDown = true;
        input.clickHandled = false;
    });

    window.addEventListener('mouseup', () => input.isDown = false);
    window.addEventListener('touchend', () => input.isDown = false);

    /**
     * Game Loop
     */
    function startGame() {
        // Initialize audio on first interaction
        initAudio();

        score = 0;
        kills = 0;
        annoyance = 0;
        flies = [];
        splatters = [];
        particles = [];
        bonuses = [];
        freezeTimer = 0;
        timeWarpFactor = 1;
        bossesSpawned = 0;
        lastBossScore = 0;
        screenShake = { x: 0, y: 0, intensity: 0 };
        handDebuffs = { shaky: 0, inverted: 0, delayed: 0, delayBuffer: [] };
        hand = new Hand();
        input.x = canvas.width/2;
        input.y = canvas.height/2;
        input.isDown = false;
        input.clickHandled = false;

        startTime = Date.now();

        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        winScreen.classList.add('hidden');
        hud.classList.remove('hidden');

        // Initialize buzz sound system
        initBuzzSystem();

        gameState = 'PLAYING';
    }

    function endGame() {
        gameState = 'GAMEOVER';
        stopBuzzSystem();
        hud.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
        finalScoreDisplay.innerText = score;
    }

    function winGame() {
        gameState = 'WIN';
        stopBuzzSystem();
        hud.classList.add('hidden');
        winScreen.classList.remove('hidden');
        let elapsed = (Date.now() - startTime) / 1000;
        finalTimeDisplay.innerText = elapsed.toFixed(1);
    }

    function drawStartScreenFly() {
        // Draw a giant stylized fly face in the background
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        // Bobbing animation
        const bob = Math.sin(frames * 0.02) * 20;
        const wingFlap = Math.sin(frames * 0.3) * 15;

        ctx.save();
        ctx.translate(cx, cy + bob - 30);
        ctx.scale(2.5, 2.5); // Make it huge

        // Glow effect behind fly
        ctx.shadowBlur = 40;
        ctx.shadowColor = 'rgba(200, 0, 0, 0.5)';

        // Wings (behind head)
        ctx.fillStyle = 'rgba(180, 220, 255, 0.4)';
        ctx.strokeStyle = 'rgba(100, 150, 200, 0.6)';
        ctx.lineWidth = 2;
        // Left wing
        ctx.save();
        ctx.translate(-80, -20);
        ctx.rotate(-0.3 + wingFlap * 0.02);
        ctx.beginPath();
        ctx.ellipse(0, 0, 70, 35, -0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        // Wing veins
        ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(-50, -15);
        ctx.moveTo(0, 0); ctx.lineTo(-55, 10);
        ctx.moveTo(0, 0); ctx.lineTo(-40, 25);
        ctx.stroke();
        ctx.restore();
        // Right wing
        ctx.save();
        ctx.translate(80, -20);
        ctx.rotate(0.3 - wingFlap * 0.02);
        ctx.beginPath();
        ctx.ellipse(0, 0, 70, 35, 0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(50, -15);
        ctx.moveTo(0, 0); ctx.lineTo(55, 10);
        ctx.moveTo(0, 0); ctx.lineTo(40, 25);
        ctx.stroke();
        ctx.restore();

        // Head with gradient
        let headGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 100);
        headGrad.addColorStop(0, '#444');
        headGrad.addColorStop(0.5, '#222');
        headGrad.addColorStop(1, '#111');
        ctx.fillStyle = headGrad;
        ctx.beginPath();
        ctx.ellipse(0, 0, 100, 80, 0, 0, Math.PI*2);
        ctx.fill();

        // Fuzz (Enhanced)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 3;
        for(let i=0; i<360; i+=8) {
            let rad = i * (Math.PI/180);
            let len = 15 + Math.sin(i * 0.5) * 5;
            ctx.beginPath();
            ctx.moveTo(Math.cos(rad)*85, Math.sin(rad)*65);
            ctx.lineTo(Math.cos(rad)*(85+len), Math.sin(rad)*(65+len*0.8));
            ctx.stroke();
        }

        // Eyes (Compound) - Brighter red with glow
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#ff0000';
        let eyeGrad = ctx.createRadialGradient(-50, -25, 5, -50, -20, 50);
        eyeGrad.addColorStop(0, '#ff4444');
        eyeGrad.addColorStop(0.5, '#cc0000');
        eyeGrad.addColorStop(1, '#880000');
        ctx.fillStyle = eyeGrad;
        // Left Eye
        ctx.beginPath();
        ctx.ellipse(-50, -20, 45, 55, -0.2, 0, Math.PI*2);
        ctx.fill();
        // Right Eye
        let eyeGrad2 = ctx.createRadialGradient(50, -25, 5, 50, -20, 50);
        eyeGrad2.addColorStop(0, '#ff4444');
        eyeGrad2.addColorStop(0.5, '#cc0000');
        eyeGrad2.addColorStop(1, '#880000');
        ctx.fillStyle = eyeGrad2;
        ctx.beginPath();
        ctx.ellipse(50, -20, 45, 55, 0.2, 0, Math.PI*2);
        ctx.fill();

        // Eye hexagon pattern (compound eye effect)
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        for(let ex = -80; ex < 0; ex += 12) {
            for(let ey = -60; ey < 30; ey += 10) {
                let dx = ex + 50;
                let dy = ey + 20;
                if(dx*dx/(40*40) + dy*dy/(50*50) < 0.85) {
                    ctx.beginPath();
                    ctx.arc(ex, ey, 4, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }
        for(let ex = 20; ex < 100; ex += 12) {
            for(let ey = -60; ey < 30; ey += 10) {
                let dx = ex - 50;
                let dy = ey + 20;
                if(dx*dx/(40*40) + dy*dy/(50*50) < 0.85) {
                    ctx.beginPath();
                    ctx.arc(ex, ey, 4, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        // Eye Highlights
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(-60, -35, 15, 20, -0.3, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(40, -35, 15, 20, 0.3, 0, Math.PI*2);
        ctx.fill();

        // Antennae
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-30, -70);
        ctx.quadraticCurveTo(-40, -100, -25, -115);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(30, -70);
        ctx.quadraticCurveTo(40, -100, 25, -115);
        ctx.stroke();
        // Antennae tips
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.ellipse(-25, -118, 8, 12, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(25, -118, 8, 12, 0, 0, Math.PI*2);
        ctx.fill();

        // Proboscis
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath();
        ctx.moveTo(-12, 60);
        ctx.quadraticCurveTo(-5, 100, -15, 130);
        ctx.lineTo(15, 130);
        ctx.quadraticCurveTo(5, 100, 12, 60);
        ctx.fill();

        // Sucker with segments
        ctx.fillStyle = '#3a3a3a';
        ctx.beginPath();
        ctx.ellipse(0, 135, 18, 12, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-15, 135); ctx.lineTo(15, 135);
        ctx.moveTo(-12, 140); ctx.lineTo(12, 140);
        ctx.stroke();

        ctx.restore();
    }

    function drawBackground() {
        const tileSize = 50;
        const rows = Math.ceil(canvas.height / tileSize);
        const cols = Math.ceil(canvas.width / tileSize);

        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#ffcccc'; // Light red
        
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if ((r + c) % 2 === 0) {
                    ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);
                }
            }
        }

        // Frozen overlay effect
        if (freezeTimer > 0) {
            ctx.fillStyle = 'rgba(135, 206, 250, 0.2)';
            ctx.fillRect(0,0, canvas.width, canvas.height);
        }
    }

    function loop() {
        frames++;

        if (gameState === 'START') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawStartScreenFly();

            // Draw and update menu hand
            if (!menuHand) {
                menuHand = new Hand();
                menuHand.weapon = 'HAND';
            }

            // Update menu hand position
            menuHand.targetX = input.x;
            menuHand.targetY = input.y;
            menuHand.x += (menuHand.targetX - menuHand.x) * 0.2;
            menuHand.y += (menuHand.targetY - menuHand.y) * 0.2;
            menuHand.angle = (menuHand.targetX - menuHand.x) * 0.005;

            // Handle slap animation
            if (menuHand.slapState === 'IDLE') {
                if (input.isDown && !input.clickHandled) {
                    menuHand.slapState = 'SLAPPING';
                    menuHand.slapTimer = 0;
                    input.clickHandled = true;
                }
            } else if (menuHand.slapState === 'SLAPPING') {
                menuHand.slapTimer++;
                menuHand.scale = 1 - (menuHand.slapTimer / 5) * 0.2;
                if (menuHand.slapTimer >= 5) {
                    // Check if hitting play button
                    const playBtn = document.getElementById('playBtn');
                    if (playBtn) {
                        const rect = playBtn.getBoundingClientRect();
                        const hitX = menuHand.x;
                        const hitY = menuHand.y - 50;
                        if (hitX > rect.left && hitX < rect.right && hitY > rect.top && hitY < rect.bottom) {
                            // Hit the play button!
                            playThwack(true);
                            triggerScreenShake(10);
                            initAudio();
                            startGame();
                            loop();
                            return;
                        }
                    }
                    menuHand.slapState = 'RECOVERING';
                    menuHand.slapTimer = 0;
                }
            } else if (menuHand.slapState === 'RECOVERING') {
                menuHand.slapTimer++;
                menuHand.scale += 0.2;
                if (menuHand.slapTimer >= 10) {
                    menuHand.scale = 1;
                    menuHand.slapState = 'IDLE';
                }
            }

            // Draw menu hand on top canvas
            handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
            menuHand.draw(handCtx);

            requestAnimationFrame(loop);
            return;
        }

        if (gameState !== 'PLAYING') return;

        // Clear hand canvas for game hand
        handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

        // Modifiers
        if (freezeTimer > 0) freezeTimer--;

        // Screen shake decay
        if (screenShake.intensity > 0) {
            screenShake.x = randomRange(-screenShake.intensity, screenShake.intensity);
            screenShake.y = randomRange(-screenShake.intensity, screenShake.intensity);
            screenShake.intensity *= 0.9;
            if (screenShake.intensity < 0.5) screenShake.intensity = 0;
        } else {
            screenShake.x = 0;
            screenShake.y = 0;
        }

        // Timer
        let elapsed = (Date.now() - startTime) / 1000;
        timerDisplay.innerText = elapsed.toFixed(1);

        // Update UI
        scoreDisplay.innerText = score;
        annoyanceBar.style.width = annoyance + '%';

        // Show debuff indicators
        if (handDebuffs.shaky > 0 || handDebuffs.inverted > 0 || handDebuffs.delayed > 0) {
            let debuffText = [];
            if (handDebuffs.shaky > 0) debuffText.push('SHAKY');
            if (handDebuffs.inverted > 0) debuffText.push('INVERTED');
            if (handDebuffs.delayed > 0) debuffText.push('LAGGED');
            // Visual feedback handled in hand draw
        }

        // Annoyance Check
        if (annoyance >= MAX_ANNOYANCE) {
            endGame();
            return;
        }

        // Boss Spawn Logic
        trySpawnBoss();

        // Spawn Logic (affected by time warp)
        const spawnRate = Math.max(15, 100 - (score * 2));
        if (frames % Math.round(spawnRate / timeWarpFactor) === 0) {
            flies.push(new Fly());
        }

        // Bonus Spawn Logic (Rare)
        if (frames % 600 === 0 && Math.random() < 0.7) { // Every ~10 seconds
            bonuses.push(new Bonus());
        }

        // Clear and apply screen shake
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(screenShake.x, screenShake.y);

        drawBackground();

        // Time warp visual effect
        if (timeWarpFactor !== 1) {
            ctx.fillStyle = timeWarpFactor < 1 ? 'rgba(100, 150, 255, 0.1)' : 'rgba(255, 150, 100, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Update & Draw Splatters (Background layer)
        for (let i = splatters.length - 1; i >= 0; i--) {
            splatters[i].update();
            splatters[i].draw(ctx);
            if (splatters[i].life <= 0) splatters.splice(i, 1);
        }

        // Update & Draw Bonuses
        for (let i = bonuses.length - 1; i >= 0; i--) {
            bonuses[i].update();
            bonuses[i].draw(ctx);
            if (!bonuses[i].active) bonuses.splice(i, 1);
        }

        // Update & Draw Flies (apply time warp to regular flies)
        for (let i = flies.length - 1; i >= 0; i--) {
            // Regular flies are affected by time warp
            if (!flies[i].bossType || flies[i].bossType === 'EGG') {
                for (let t = 0; t < timeWarpFactor; t++) {
                    flies[i].update();
                }
            } else {
                flies[i].update();
            }
            flies[i].draw(ctx);
        }

        // Hand Logic & Collision
        hand.update();

        // Remove dead flies
        flies = flies.filter(f => !f.isDead);

        // Update buzz volume based on fly count
        updateBuzzVolume();

        // Update & Draw Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw(ctx);
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // Draw Hand on top canvas (Foreground)
        hand.draw(handCtx);

        // Draw debuff indicators on screen
        if (handDebuffs.shaky > 0 || handDebuffs.inverted > 0 || handDebuffs.delayed > 0) {
            ctx.font = 'bold 16px Fredoka One';
            ctx.textAlign = 'center';
            let yOff = canvas.height - 50;
            if (handDebuffs.shaky > 0) {
                ctx.fillStyle = '#9b59b6';
                ctx.fillText('SHAKY! ' + Math.ceil(handDebuffs.shaky / 60) + 's', canvas.width/2 - 80, yOff);
            }
            if (handDebuffs.inverted > 0) {
                ctx.fillStyle = '#3498db';
                ctx.fillText('INVERTED! ' + Math.ceil(handDebuffs.inverted / 60) + 's', canvas.width/2, yOff);
            }
            if (handDebuffs.delayed > 0) {
                ctx.fillStyle = '#f39c12';
                ctx.fillText('LAGGED! ' + Math.ceil(handDebuffs.delayed / 60) + 's', canvas.width/2 + 80, yOff);
            }
        }

        ctx.restore(); // End screen shake transform

        requestAnimationFrame(loop);
    }

    // Buttons (play is handled by hand slap in start screen)
    restartBtn.addEventListener('click', () => {
        startGame();
        loop();
    });
    winRestartBtn.addEventListener('click', () => {
        startGame();
        loop();
    });

    // Start Animation Loop Immediately for Cover Art
    loop();

</script>
<script src="/game-wrapper.js"></script>
</body>
</html>